package gg.mixed;

import gg.binaryTree.TreeNode;
import gg.binaryTree.TreeNodeInsertion;
import gg.doubly.Node;
import gg.doubly.doubleLinkedListInsertion;

public class circulationDoubleLinkedListConvertion {

	public static void main(String args[]){
		TreeNode n1=new TreeNode(10);
		TreeNodeInsertion.insertNode(n1, 11);
		TreeNodeInsertion.insertNode(n1, 5);
		TreeNodeInsertion.insertNode(n1, 6);
		TreeNodeInsertion.insertNode(n1, 8);
		TreeNodeInsertion.insertNode(n1, 1);
		TreeNode.printTreeNode(n1);
		Node head=ConvertBinaryTreeToCircularLinkedList(n1);
		printCircularDoubleLinkedList(head);

	}	
	static class Node{
		int data;
		Node prev;
		Node next;
		public Node(int data){
			this.data=data;
		}
	}
	public static void printCircularDoubleLinkedList(Node head){
		
		Node temp=head;
		System.out.print("Circular Data : ");
		while(temp.next!=head){
			System.out.print(temp.data +" ");
			temp=temp.next;
		}
		System.out.println(temp.data);
		
	}
	
	public static Node ConvertBinaryTreeToCircularLinkedList(TreeNode head){
		
		Node nHead=convertionUtil(null,head );
		
		return nHead;
	}
	
    public Node concatenate(Node leftList,Node rightList) 
    { 
        // If either of the list is empty, then 
        // return the other list 
        if (leftList == null) 
            return rightList; 
        if (rightList == null) 
            return leftList; 
  
        // Store the last Node of left List 
        Node leftLast = leftList.left; 
  
        // Store the last Node of right List 
        Node rightLast = rightList.left; 
  
        // Connect the last node of Left List 
        // with the first Node of the right List 
        leftLast.right = rightList; 
        rightList.left = leftLast; 
  
        // left of first node refers to 
        // the last node in the list 
        leftList.left = rightLast; 
  
        // Right of last node refers to the first 
        // node of the List 
        rightLast.right = leftList; 
  
        // Return the Head of the List 
        return leftList; 
    } 
  
    // Method converts a tree to a circular 
    // Link List and then returns the head 
    // of the Link List 
    public Node bTreeToCList(Node root) 
    { 
        if (root == null) 
            return null; 
  
        // Recursively convert left and right subtrees 
        Node left = bTreeToCList(root.left); 
        Node right = bTreeToCList(root.right); 
  
        // Make a circular linked list of single node 
        // (or root). To do so, make the right and 
        // left pointers of this node point to itself 
        root.left = root.right = root; 
  
        // Step 1 (concatenate the left list with the list  
        //         with single node, i.e., current node) 
        // Step 2 (concatenate the returned list with the 
        //         right List) 
        return concatenate(concatenate(left, root), right); 
    } 
