package gg.binaryTree;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class TreeNodeLevelOrder {

	public static void main(String args[]){
		TreeNode =TreeNodeInsertion.insertNode(null,1);
		.left=new TreeNode(2);
		.right=new TreeNode(3);
		.left.left=new TreeNode(4);
		.left.right=new TreeNode(5);
		System.out.print("Iterative: ");
		iterativeLevelOrderTraversal();
		System.out.print("\n Recursive:");
		recursiveLevelOrderTraversal();System.out.println();
		
		System.out.print("ReverseLevelOrder ");
		reverseLevelOrder();
		
		
		
		
        TreeNode tree = new TreeNode(); 
        tree.root = new TreeNode(1); 
        tree.root.left = new TreeNode(2); 
        tree.root.right = new TreeNode(3); 
   
        tree.root.left.left = new TreeNode(4); 
        tree.root.left.right = new TreeNode(5); 
        tree.root.right.left = new TreeNode(6); 
        tree.root.right.right = new TreeNode(7); 
   
        tree.root.left.left.left = new TreeNode(8); 
        tree.root.left.left.right = new TreeNode(9); 
        tree.root.left.right.left = new TreeNode(10); 
        tree.root.left.right.right = new TreeNode(11); 
        tree.root.right.left.left = new TreeNode(12); 
        tree.root.right.left.right = new TreeNode(13); 
        tree.root.right.right.left = new TreeNode(14); 
        tree.root.right.right.right = new TreeNode(15); 
   
        tree.root.left.left.left.left = new TreeNode(16); 
        tree.root.left.left.left.right = new TreeNode(17); 
        tree.root.left.left.right.left = new TreeNode(18); 
        tree.root.left.left.right.right = new TreeNode(19); 
        tree.root.left.right.left.left = new TreeNode(20); 
        tree.root.left.right.left.right = new TreeNode(21); 
        tree.root.left.right.right.left = new TreeNode(22); 
        tree.root.left.right.right.right = new TreeNode(23); 
        tree.root.right.left.left.left = new TreeNode(24); 
        tree.root.right.left.left.right = new TreeNode(25); 
        tree.root.right.left.right.left = new TreeNode(26); 
        tree.root.right.left.right.right = new TreeNode(27); 
        tree.root.right.right.left.left = new TreeNode(28); 
        tree.root.right.right.left.right = new TreeNode(29); 
        tree.root.right.right.right.left = new TreeNode(30); 
        tree.root.right.right.right.right = new TreeNode(31); 

		
		
		
		
		
		specificOrderLevelOrderTraversal();
	}
	
	public static void iterativeLevelOrderTraversal(TreeNode ){
		//Same as BreadthFirstTraversal 
	
	}
	static int maxLevel=0;
	public static void recursiveLevelOrderTraversal(TreeNode ){
		findMaxLevelMethod(, 0);
		
		System.out.println("MaxLevel is "+ maxLevel);
		for(int i=1;i<=maxLevel;i++){
			recursiveUtilLevelOrderTraversal(, i);
			System.out.println();
		}
	}
	
	public static void findMaxLevelMethod(TreeNode ,int level){
		if(==null){
			return;
		}
			level++;
		

		if(maxLevel<level){
			maxLevel=level;
		}

		findMaxLevelMethod(.left, level);
		
		findMaxLevelMethod(.right, level);
	}

	public static void recursiveUtilLevelOrderTraversal(TreeNode ,int level){
		if(==null){
			return;
		}
		level--;
		if(level==0)
		System.out.print(.data+" ");
		
		recursiveUtilLevelOrderTraversal(.left, level);

		recursiveUtilLevelOrderTraversal(.right, level);

	}
	public static void reverseLevelOrder(TreeNode ){
		Stack<TreeNode> st=reverseLevelOrderTraversalUtil();
		
		Stack<TreeNode> rst=new Stack<TreeNode>();
		System.out.println("    -- "+st.size());
		
		while(!st.isEmpty()){
			System.out.print( "asd");

			TreeNode temp=st.pop();
			if(temp==null){
				while(!rst.isEmpty()){
					System.out.print( "asd");
				}
				System.out.println();
			}else{
				rst.push(temp);
				System.out.println(temp.data);
			}
				
			}
		}
	
	public static Stack reverseLevelOrderTraversalUtil(TreeNode ){
		
		Queue<TreeNode> q=new LinkedList<TreeNode>();
		
		TreeNode temp=;
		Stack<TreeNode> st=new Stack<TreeNode>();

		q.add();

		while(!q.isEmpty()){
			temp=q.poll();
			st.add(temp);
			if(temp.left!=null)
				q.add(temp.left);
			if(temp.right!=null)
				q.add(temp.right);

		}
		while(!st.isEmpty()){
			System.out.print("->"+st.pop().data+" ");
		}
		
		return st;
	}
	
	public static void specificOrderLevelOrderTraversal(TreeNode ){
		if(==null){
			return;
		}
		System.out.print("SpecificOrderTraversal : " );
		System.out.print(.data+" ");
		Queue<TreeNode> q=new LinkedList<>(); 
		
		q.add(.left);
		q.add(.right);
		specificOrderLevelOrderTraversalUtil(q);
		System.out.println();
	}
	
	public static void specificOrderLevelOrderTraversalUtil(Queue<TreeNode> q){
		if(q.isEmpty())
			return ;
		TreeNode left=q.poll();
		TreeNode right=q.poll();
		
		System.out.print(" "+left.data+" "+right.data );

		pushValidToQueue(left.left, q);
		pushValidToQueue(right.right, q);
		pushValidToQueue(left.right, q);
		pushValidToQueue(right.left, q);
		
		specificOrderLevelOrderTraversalUtil(q);
		
	}
	
	public static void pushValidToQueue(TreeNode ,Queue<TreeNode> q){
		if(==null)
			return;
		q.add();
	}
}
