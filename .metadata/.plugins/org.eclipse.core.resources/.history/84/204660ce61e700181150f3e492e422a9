package gg.binaryTree;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class TreeNodeLevelOrder {

	public static void main(String args[]){
		TreeNode head=TreeNodeInsertion.insertNode(null,1);
		head.left=new TreeNode(2);
		head.right=new TreeNode(3);
		head.left.left=new TreeNode(4);
		head.left.right=new TreeNode(5);
		System.out.print("Iterative: ");
		iterativeLevelOrderTraversal(head);
		System.out.print("\n Recursive:");
		recursiveLevelOrderTraversal(head);System.out.println();
		
		System.out.print("ReverseLevelOrder ");
		reverseLevelOrder(head);
		
		
		
		
        BinaryTree tree = new BinaryTree(); 
        tree.root = new Node(1); 
        tree.root.left = new Node(2); 
        tree.root.right = new Node(3); 
   
        tree.root.left.left = new Node(4); 
        tree.root.left.right = new Node(5); 
        tree.root.right.left = new Node(6); 
        tree.root.right.right = new Node(7); 
   
        tree.root.left.left.left = new Node(8); 
        tree.root.left.left.right = new Node(9); 
        tree.root.left.right.left = new Node(10); 
        tree.root.left.right.right = new Node(11); 
        tree.root.right.left.left = new Node(12); 
        tree.root.right.left.right = new Node(13); 
        tree.root.right.right.left = new Node(14); 
        tree.root.right.right.right = new Node(15); 
   
        tree.root.left.left.left.left = new Node(16); 
        tree.root.left.left.left.right = new Node(17); 
        tree.root.left.left.right.left = new Node(18); 
        tree.root.left.left.right.right = new Node(19); 
        tree.root.left.right.left.left = new Node(20); 
        tree.root.left.right.left.right = new Node(21); 
        tree.root.left.right.right.left = new Node(22); 
        tree.root.left.right.right.right = new Node(23); 
        tree.root.right.left.left.left = new Node(24); 
        tree.root.right.left.left.right = new Node(25); 
        tree.root.right.left.right.left = new Node(26); 
        tree.root.right.left.right.right = new Node(27); 
        tree.root.right.right.left.left = new Node(28); 
        tree.root.right.right.left.right = new Node(29); 
        tree.root.right.right.right.left = new Node(30); 
        tree.root.right.right.right.right = new Node(31); 

		
		
		
		
		
		specificOrderLevelOrderTraversal();
	}
	
	public static void iterativeLevelOrderTraversal(TreeNode head){
		//Same as BreadthFirstTraversal 
	
	}
	static int maxLevel=0;
	public static void recursiveLevelOrderTraversal(TreeNode head){
		findMaxLevelMethod(head, 0);
		
		System.out.println("MaxLevel is "+ maxLevel);
		for(int i=1;i<=maxLevel;i++){
			recursiveUtilLevelOrderTraversal(head, i);
			System.out.println();
		}
	}
	
	public static void findMaxLevelMethod(TreeNode head,int level){
		if(head==null){
			return;
		}
			level++;
		

		if(maxLevel<level){
			maxLevel=level;
		}

		findMaxLevelMethod(head.left, level);
		
		findMaxLevelMethod(head.right, level);
	}

	public static void recursiveUtilLevelOrderTraversal(TreeNode head,int level){
		if(head==null){
			return;
		}
		level--;
		if(level==0)
		System.out.print(head.data+" ");
		
		recursiveUtilLevelOrderTraversal(head.left, level);

		recursiveUtilLevelOrderTraversal(head.right, level);

	}
	public static void reverseLevelOrder(TreeNode head){
		Stack<TreeNode> st=reverseLevelOrderTraversalUtil(head);
		
		Stack<TreeNode> rst=new Stack<TreeNode>();
		System.out.println("    -- "+st.size());
		
		while(!st.isEmpty()){
			System.out.print( "asd");

			TreeNode temp=st.pop();
			if(temp==null){
				while(!rst.isEmpty()){
					System.out.print( "asd");
				}
				System.out.println();
			}else{
				rst.push(temp);
				System.out.println(temp.data);
			}
				
			}
		}
	
	public static Stack reverseLevelOrderTraversalUtil(TreeNode head){
		
		Queue<TreeNode> q=new LinkedList<TreeNode>();
		
		TreeNode temp=head;
		Stack<TreeNode> st=new Stack<TreeNode>();

		q.add(head);

		while(!q.isEmpty()){
			temp=q.poll();
			st.add(temp);
			if(temp.left!=null)
				q.add(temp.left);
			if(temp.right!=null)
				q.add(temp.right);

		}
		while(!st.isEmpty()){
			System.out.print("->"+st.pop().data+" ");
		}
		
		return st;
	}
	
	public static void specificOrderLevelOrderTraversal(TreeNode head){
		if(head==null){
			return;
		}
		System.out.print("SpecificOrderTraversal : " );
		System.out.print(head.data+" ");
		Queue<TreeNode> q=new LinkedList<>(); 
		
		q.add(head.left);
		q.add(head.right);
		specificOrderLevelOrderTraversalUtil(q);
		System.out.println();
	}
	
	public static void specificOrderLevelOrderTraversalUtil(Queue<TreeNode> q){
		if(q.isEmpty())
			return ;
		TreeNode left=q.poll();
		TreeNode right=q.poll();
		
		System.out.print(" "+left.data+" "+right.data );

		pushValidToQueue(left.left, q);
		pushValidToQueue(right.right, q);
		pushValidToQueue(left.right, q);
		pushValidToQueue(right.left, q);
		
		specificOrderLevelOrderTraversalUtil(q);
		
	}
	
	public static void pushValidToQueue(TreeNode head,Queue<TreeNode> q){
		if(head==null)
			return;
		q.add(head);
	}
}
